import { NextRequest, NextResponse } from "next/server"
import { createServiceClient } from "@/lib/supabase/service"

export const dynamic = "force-dynamic"
export const maxDuration = 30

interface VisitFrequency {
  discipline: "RN" | "PT" | "OT" | "MSW" | "HHA"
  authorized: number
  used: number
  remaining: number
  weeklyFrequency: string
  lastVisit: string
  nextScheduled: string
  lupaThreshold: number
  isOverThreshold: boolean
  costPerVisit: number
  totalCost: number
}

interface PatientGoal {
  id: string
  discipline: string
  goal: string
  targetDate: string
  status: "Not Started" | "In Progress" | "Achieved" | "Modified" | "Discontinued"
  progress: number
  notes: string
}

interface DMEOrder {
  id: string
  supplier: "Parachute Health" | "Verse Medical"
  status: "pending" | "approved" | "shipped" | "delivered" | "cancelled"
  orderDate: string
  estimatedDelivery?: string
  trackingNumber?: string
  items: Array<{
    name: string
    quantity: number
    category: string
    cost: number
  }>
  totalCost: number
  insuranceCoverage: string
  autoGenerated: boolean
  notes?: string
}

interface WoundCare {
  hasWounds: boolean
  woundCount: number
  woundTypes: string[]
  lastAssessment: string
  healingProgress: "Improving" | "Stable" | "Declining"
  nextDressing: string
  supplies: string[]
}

interface Patient {
  id: string
  name: string
  axxessId: string
  referralDate: string
  currentStatus: "Active" | "Pending" | "Discharged" | "On Hold"
  dischargeStatus: "N/A" | "Completed" | "Transferred" | "Deceased" | "Against Medical Advice"
  referralAccepted: boolean
  assignedStaff: string // Nurse/Staff who does home visits
  assignedStaffId?: string | null
  primaryProvider?: string // Doctor who oversees care
  primaryProviderId?: string | null // Doctor ID
  socDueDate: string
  socWindowStatus: "On Track" | "Due Soon" | "Overdue"
  location: string
  referralType: "Hospital" | "Facility" | "Clinic"
  priority: "High" | "Medium" | "Low"
  diagnosis: string
  age: number
  insurance: string
  phoneNumber: string
  address: string
  emergencyContact: string
  episodeStartDate: string
  episodeEndDate: string
  nextReEvalDate: string
  lupaStatus: "Safe" | "At Risk" | "Over Threshold"
  totalEpisodeCost: number
  projectedCost: number
  visitFrequencies: VisitFrequency[]
  patientGoals: PatientGoal[]
  dmeOrders: DMEOrder[]
  woundCare?: WoundCare
}

// Calculate SOC window status based on current date
function calculateSOCStatus(socDueDate: string | null): "On Track" | "Due Soon" | "Overdue" {
  if (!socDueDate) return "On Track"
  
  const today = new Date()
  today.setHours(0, 0, 0, 0)
  const dueDate = new Date(socDueDate)
  dueDate.setHours(0, 0, 0, 0)
  const timeDiff = dueDate.getTime() - today.getTime()
  const hoursDiff = timeDiff / (1000 * 3600)

  if (hoursDiff < 0) return "Overdue"
  if (hoursDiff < 24) return "Due Soon"
  return "On Track"
}

// Calculate LUPA status based on visit frequencies
function calculateLupaStatus(visitFrequencies: VisitFrequency[]): "Safe" | "At Risk" | "Over Threshold" {
  if (!visitFrequencies || visitFrequencies.length === 0) return "Safe"
  
  const overThreshold = visitFrequencies.some((vf) => vf.isOverThreshold)
  if (overThreshold) return "Over Threshold"
  
  const atRisk = visitFrequencies.some((vf) => {
    const remaining = vf.remaining
    const threshold = vf.lupaThreshold
    return remaining <= threshold * 0.3 && remaining > 0
  })
  if (atRisk) return "At Risk"
  
  return "Safe"
}

// Transform database row to frontend format
function transformPatient(row: any, staffName: string = "", primaryProviderName: string = ""): Patient {
  const visitFrequencies: VisitFrequency[] = row.visit_frequencies || []
  const patientGoals: PatientGoal[] = row.patient_goals || []
  const dmeOrders: DMEOrder[] = row.dme_orders || []
  const woundCare: WoundCare | undefined = row.wound_care

  // Calculate LUPA status
  const lupaStatus = calculateLupaStatus(visitFrequencies)
  
  // Calculate SOC status
  const socWindowStatus = calculateSOCStatus(row.soc_due_date)

  return {
    id: row.id,
    name: row.name || "",
    axxessId: row.axxess_id || "",
    medicalRecordNumber: row.patient_id || row.medical_record_number || row.axxess_id || "",
    referralDate: row.referral_date || "",
    currentStatus: (row.current_status as any) || "Pending",
    dischargeStatus: (row.discharge_status as any) || "N/A",
    referralAccepted: row.referral_accepted || false,
    assignedStaff: staffName || "Unassigned", // Nurse/Staff who does home visits
    assignedStaffId: row.assigned_staff_id || null,
    primaryProvider: primaryProviderName || "", // Doctor who oversees care
    primaryProviderId: row.primary_provider_id || null,
    socDueDate: row.soc_due_date || "",
    socWindowStatus,
    location: row.location || "",
    referralType: (row.referral_type as any) || "Clinic",
    priority: (row.priority as any) || "Low",
    diagnosis: row.diagnosis || "",
    age: row.age || 0,
    dateOfBirth: row.date_of_birth || "",
    insurance: row.insurance || "",
    phoneNumber: row.phone_number || "",
    address: row.address || "",
    emergencyContact: row.emergency_contact || "",
    episodeStartDate: row.episode_start_date || "",
    episodeEndDate: row.episode_end_date || "",
    nextReEvalDate: row.next_re_eval_date || "",
    lupaStatus,
    totalEpisodeCost: parseFloat(row.total_episode_cost) || 0,
    projectedCost: parseFloat(row.projected_cost) || 0,
    visitFrequencies,
    patientGoals,
    dmeOrders,
    woundCare,
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const search = searchParams.get("search")
    const staffFilter = searchParams.get("staff")
    const locationFilter = searchParams.get("location")
    const statusFilter = searchParams.get("status")
    const referralTypeFilter = searchParams.get("referralType")
    const lupaFilter = searchParams.get("lupa")

    const supabase = createServiceClient()

    // Build query - fetch patients first, then join staff separately
    let query = supabase
      .from("patients")
      .select("*")
      .order("created_at", { ascending: false })

    // Apply filters
    if (staffFilter && staffFilter !== "All") {
      // Get staff ID from name
      const { data: staffData } = await supabase
        .from("staff")
        .select("id")
        .ilike("name", `%${staffFilter}%`)
        .limit(1)
      
      if (staffData && staffData.length > 0) {
        query = query.eq("assigned_staff_id", staffData[0].id)
      }
    }

    if (locationFilter && locationFilter !== "All") {
      query = query.eq("location", locationFilter)
    }

    if (referralTypeFilter && referralTypeFilter !== "All") {
      query = query.eq("referral_type", referralTypeFilter)
    }

    const { data: patientsData, error } = await query

    if (error) {
      console.error("Error fetching patients:", error)
      return NextResponse.json(
        {
          success: false,
          error: "Failed to fetch patients: " + error.message,
          patients: [],
        },
        { status: 500 }
      )
    }

    // Fetch staff data separately and create maps for both assigned staff and primary provider
    const assignedStaffIds = [...new Set((patientsData || []).map((p: any) => p.assigned_staff_id).filter(Boolean))]
    const primaryProviderIds = [...new Set((patientsData || []).map((p: any) => p.primary_provider_id).filter(Boolean))]
    const allStaffIds = [...new Set([...assignedStaffIds, ...primaryProviderIds])]
    
    const staffMap = new Map<string, string>()
    const providerMap = new Map<string, string>()
    
    if (allStaffIds.length > 0) {
      const { data: staffData } = await supabase
        .from("staff")
        .select("id, name")
        .in("id", allStaffIds)
      
      if (staffData) {
        staffData.forEach((staff: any) => {
          // Add to both maps (staff can be either assigned staff or primary provider)
          staffMap.set(staff.id, staff.name)
          providerMap.set(staff.id, staff.name)
        })
      }
    }

    // Transform and filter patients
    let transformedPatients = (patientsData || []).map((row: any) => {
      const staffName = row.assigned_staff_id ? (staffMap.get(row.assigned_staff_id) || "Unassigned") : "Unassigned"
      const providerName = row.primary_provider_id ? (providerMap.get(row.primary_provider_id) || "") : ""
      return transformPatient(row, staffName, providerName)
    })

    // Apply client-side filters that require transformed data
    if (search) {
      const searchLower = search.toLowerCase()
      transformedPatients = transformedPatients.filter(
        (patient) =>
          patient.name?.toLowerCase().includes(searchLower) ||
          patient.id?.toLowerCase().includes(searchLower) ||
          patient.axxessId?.toLowerCase().includes(searchLower) ||
          patient.diagnosis?.toLowerCase().includes(searchLower)
      )
    }

    if (statusFilter && statusFilter !== "All") {
      transformedPatients = transformedPatients.filter(
        (patient) => patient.socWindowStatus === statusFilter
      )
    }

    if (lupaFilter && lupaFilter !== "All") {
      transformedPatients = transformedPatients.filter(
        (patient) => patient.lupaStatus === lupaFilter
      )
    }

    return NextResponse.json({
      success: true,
      patients: transformedPatients,
      count: transformedPatients.length,
      timestamp: new Date().toISOString(),
    })
  } catch (error: any) {
    console.error("Unexpected error in patients API:", error)
    return NextResponse.json(
      {
        success: false,
        error: error.message || "Internal server error",
        patients: [],
      },
      { status: 500 }
    )
  }
}

